# 第五章 函数

## 5.1 函数声明

返回值也可以像形式参数一样被命名。此种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为0。

函数的类型被称为函数的**标识符**。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。

Go语言没有默认参数值(C++)，也没有任何方法可以通过参数名指定形参(python)，因此形参和返回值的变量名 对于函数调用者而言没有意义。

在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。

实参通过值的方式传递，因此函数的形参是实参的拷贝。

Go语言使用可变栈，栈的大小按需增加(初始时很小)，使用递归时不必考虑溢出和安全问题。

## 5.3 多返回值

许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。

如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数。这称之为bare	return。

> 规范：当一个函数有多处return语句以及许多返回值时，bare	return	可以减少代码的重复，但是使得 代码难以被理解。基于以上原因，不宜过度使用bare return

## 5.4 错误

对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一 个，来传递错误信息。

> 规范：
>
> * 如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok
> * 如果导致失败的原因不止一个，用户需要了解更多的错误信息，额外的返回值将是error类型

内置的error是接口类型，对于non-nil的error，可通过调用`error.Error`或者输出函数，获得字符串类型的错误信息。

通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined)，这些未定义的返回值应该被忽略。

然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如， 当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况， 正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清 晰的说明，以便于其他人使用。

Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈根据信息返回给终端用户，这些信息复杂且无用，无法帮助定位 错误。
正因此，Go使用**控制流机制**（如if和return）处理异常，这使得编码人员能更多的关注错误处 理。

### 5.4.1 错误处理策略

#### 1.传播错误

函数中某个子程序的失败，会变成该函数的失败。

可通过构造新的错误信息，帮助定位具体错误：

```go
doc, err :=html.Parse(resp.Body)
resp.Body.Close()
if err!=nil{
    return nil, fmt.Errorf("parsing %s as HTML:%v",url,err)
}
```

当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链。

一般而言，被调函数`f(x)`会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并 返回给调用者，调用者需要添加一些错误信息中不包含的信息，比如添加url到`html.Parse`返回的错误中。

#### 2.重试操作

如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。重试时需要限制重试的时间间隔或重试的次数，防止无限制的重试。

#### 3.输出错误信息并结束程序

这种策略只应在main函数中执行，对于库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。

#### 4.输出错误信息并继续运行

`log.error`

#### 5.直接忽略错误

我们应该在每次函数调用后，都养成考虑错误处理的习惯。

> 规范：
>
> * 当你决定忽略某个错误时，你应该清晰的记录下你的意图
> * 采用卫语句的方式处理错误

### 5.4.2 文件结尾错误(EOF)

io包保证任何由文件结束引起的读取失败 都返回同一个错误——io.EOF

从标准输入中读取字符，以及判断文件结束：

```go
in:=bufio.NewReader(os.Stdin)
for{
  r,_,err:=in.ReadRune()
  if err == io.EOF{
    break //end reading
  }
  if err!=nil{
    return fmt.Errorf("read failed:%v",err)
  }
  //...
}
```

## 5.5 函数值

在Go中，函数被看作第一类值(first-class values):函数像其他值一样，拥有类型，可以被 赋值给其他变量，传递给函数，从函数返回。

函数类型的零值是nil。调用值为nil的函数值会引起panic错误。

函数值之间是不可比较的，也不能用函数值作为map的key。

## 5.6 匿名函数

通过函数字面量(function literal)，可以在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被成为匿名函数 (anonymous function)。

```go
strings.Map(func(r rune) rune{return r+1},"HAL-9000")
```

函数值不仅仅是一串代码，还记录了状态。定义的匿名内部函数可以访问和更新外部函数的局部变量，这意味着匿名函数和外部函数存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。

Go使用闭包(closures)技术实 现函数值，Go程序员也把函数值叫做闭包

### 5.6.1 警告：捕获迭代变量

```go
var rmdirs []func()
for _, d := range tempDirs() {
  dir := d // NOTE: necessary!
  os.MkdirAll(dir, 0755) // creates parent directories too 
  rmdirs = append(rmdirs, func() {
  	os.RemoveAll(dir) 
  })
}
// ...do some work...
for _, rmdir := range rmdirs { 
  rmdir() // clean up
}
```

在添加函数值到切片中时，如果按照如下的写法，会出问题：

```go
for _, dir := range tempDirs() {
  os.MkdirAll(dir, 0755) // creates parent directories too 
  rmdirs = append(rmdirs, func() {
  	os.RemoveAll(dir) 
  })
}
```

因为内部匿名函数记录的是循环变量dir的地址，而不是值，所以循环结束后，每个匿名函数中的dir都是一致的，指向最后的目录，所以删除的都是同一个目录。

通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。

## 5.7 可变参数

```go
func sum()(vals...int){
  //...
}
```

函数内部，可变参数被看作是切片。

## 5.8 Deferred函数

需要在调用普通函数或方法前加上关键字`defer`，就完成了`defer`所需要的语法。当`defer`语句被执行时，跟在`defer`后面的函数会被延迟执行。直到包含该`defer`语句的函数执行完毕时， `defer`后的函数才会被执行，不论包含`defer`语句的函数是通过`return`正常结束，还是由于`panic`导致的异常结束。你可以在一个函数中执行多条`defer`语句，它们的执行顺序与声明顺序相反。

`defer`语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。

> 规范：释放资源的 defer应该直接跟在请求资源的语句后

## 5.9 painc异常

当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数，随后程序崩溃并输出日志信息。

直接调用内置的`panic`函数也会引发`panic`异常

panic一般用于**严重的错误**，对于大部分的bug，都应使用错误机制。

## 5.10 Recover捕获异常



