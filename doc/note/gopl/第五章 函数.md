# 第五章 函数

## 5.1 函数声明

返回值也可以像形式参数一样被命名。此种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为0。

函数的类型被称为函数的**标识符**。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。

Go语言没有默认参数值(C++)，也没有任何方法可以通过参数名指定形参(python)，因此形参和返回值的变量名 对于函数调用者而言没有意义。

在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。

实参通过值的方式传递，因此函数的形参是实参的拷贝。

Go语言使用可变栈，栈的大小按需增加(初始时很小)，使用递归时不必考虑溢出和安全问题。

## 5.3 多返回值

许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。

如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数。这称之为bare	return。

> 规范：当一个函数有多处return语句以及许多返回值时，bare	return	可以减少代码的重复，但是使得 代码难以被理解。基于以上原因，不宜过度使用bare return

## 5.4 错误

对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一 个，来传递错误信息。

> 规范：
>
> * 如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok
> * 如果导致失败的原因不止一个，用户需要了解更多的错误信息，额外的返回值将是error类型

内置的error是接口类型，对于non-nil的error，可通过调用`error.Error`或者输出函数，获得字符串类型的错误信息。

通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined)，这些未定义的返回值应该被忽略。

然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如， 当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况， 正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清 晰的说明，以便于其他人使用。

Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈根据信息返回给终端用户，这些信息复杂且无用，无法帮助定位 错误。
正因此，Go使用**控制流机制**（如if和return）处理异常，这使得编码人员能更多的关注错误处 理。

### 5.4.1 错误处理策略

#### 1.传播错误

函数中某个子程序的失败，会变成该函数的失败。

可通过构造新的错误信息，帮助定位具体错误：

```go
doc, err :=html.Parse(resp.Body)
resp.Body.Close()
if err!=nil{
    return nil, fmt.Errorf("parsing %s as HTML:%v",url,err)
}
```

当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链。

一般而言，被调函数`f(x)`会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并 返回给调用者，调用者需要添加一些错误信息中不包含的信息，比如添加url到`html.Parse`返回的错误中。

#### 2.重试操作

如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。重试时需要限制重试的时间间隔或重试的次数，防止无限制的重试。

#### 3.输出错误信息并结束程序

这种策略只应在main函数中执行，对于库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。

#### 4.输出错误信息并继续运行

`log.error`

#### 5.直接忽略错误

我们应该在每次函数调用后，都养成考虑错误处理的习惯。

> 规范：
>
> * 当你决定忽略某个错误时，你应该清晰的记录下你的意图
> * 采用卫语句的方式处理错误



