# 第二章 程序结构

## 2.1 命名

名字开头的大小写决定了名字在包外的可见性，大写字母开头的名字将被导出。

>  规范：
>
> 1. Go语言的风格是尽量使用短小的名字。如果一个名字的作用域较大，生命周期较长，用长的名字将更加有意义。
> 2. Go语言推荐使用驼峰式命名。

## 2.2 声明

包一级声明语句声明的名字可在整个包对应的每个源文件中访问。

## 2.3 变量

变量的零值：

* 数值：`0`
* bool：`false`
* string：`""`
* interface/slice/pointer/map/chan/func:`nil`
* array/struct：每个元素或字段对应类型的0值

零值初始化机制可确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。

### 2.3.1 简短变量声明

简短变量声明被广泛用于大部分的局部变量的声明和初始化。

* `:=`是一个变量声明语句
* `=`是一个变量赋值操作

多重声明

```go
i,j:=10,11
```

多重赋值

```go
i,j=j,i //交换两变量的值
```

简短变量声明语句中**必须至少要声明一个新的变量**

### 2.3.2 指针

一个变量对应一个保存了变量对应类型值的内存空间。

每一个变量必然有对应的内存地址，通过指针，可以直接读取或更新对应变量的值，而不需要知道变量名。

Go语言中，返回函数中局部变量的地址是安全的。

### 2.3.3 new函数

`new(T)`将创建一个`T`类型的匿名变量，初始化为对应零值，然后返回变量地址。

> new函数使用较少，对于结构体来说，直接用字面量语法创建变量的方法会更灵活

### 2.3.4 变量的生命周期

函数的参数变量和返回值变量都是局部变量，在函数每次被调用时创建。

Go的GC的基本思路与Java类似，采用可达性分析思路：从每个包级变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量，如果找不到，说明该变量不可达。

正因如此，局部变量在函数返回后可能依然存在。

编译器自动选择在栈或者堆上分配局部变量的存储空间。

## 2.4 赋值

Go语言中**自增自减是语句，不是表达式**

### 2.4.1 元组赋值

与Python类似。

```go
a,b=b,a
```

> 规范：表达式过于复杂时不推荐使用元组赋值

## 2.5 类型

类型声明创建新的类型，用于分隔不同概念的底层类型：

```go
package tempconv

type Celsius float64    // 摄氏温度
type Fahrenheit float64 //华氏温度

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
	return Fahrenheit(c*9/5 + 32)
}

func FtoC(f Fahrenheit) Celsius {
	return Celsius((f - 32) * 5 / 9)
}
```

对于每个类型T，都有一个对应的类型转换操作`T(x)`。只有当两个类型的底层类型相同时，才允许此操作。

两个值的类型不同时，即便两个类型的底层类型相同，也不能直接比较。

## 2.6 包和文件

在每个源文件的包声明前紧跟着的注释是包注释。

通常，包注释的第一句应该先 是包的功能概要说明。一个包通常只有一个源文件有包注释(译注:如果有多个包注释，目 前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释)。如果包注释很大，通 常会放到一个独立的doc.go文件中。

### 2.6.1 导入包

> 规范：包名一般是短小的名字，一个包的包名和包的导入路径相同

### 2.6.2 包的初始化

包的初始化首先解决包级变量的依赖顺序，然后按照**包级变量声明出现的顺序**依次初始化。

在每个文件中的init函数按照声明的顺序被自动调用。

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只被初始化一次。初始化工作自上而下进行，main包最后初始化。

## 2.7 作用域

> 规范：Go语言的习惯是在if中处理错误后直接返回

