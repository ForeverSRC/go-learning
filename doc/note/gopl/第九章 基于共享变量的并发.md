# 第九章 基于共享变量的并发

## 9.1 竞态条件

当没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明这两个事件是并发的。

并发安全的函数：在并发条件下可以正确工作的函数，不需要额外的同步工作

三种方法避免数据竞争：

* 不要去写变量
* 避免多个goroutine访问变量，把变量的访问操作限制在一个goroutine中
  * “不要使用共享数据通信，使用通信共享数据”
  * 一个提供对某个指定的变量通过channel来请求的goroutine叫做这个变量的monitor goroutine
* 允许多个goroutine访问，但同一时刻只能有一个goroutine访问

## 9.2 sync.Mutex互斥锁

可以用一个容量只有1的channel来保证最多只有 一个goroutine在同一时刻访问一个共享变量，作为一个互斥锁。

用defer来调用Unlock，临界区会隐式地延伸到函数作用域的最后，并且在发生panic时依然可以释放锁。但是要注意临界区的长度是否过长。

```go
//...
mu.Lock()
defer mu.Unlock()
//....
```

> 规范：如果可能的话尽量使用defer来将临界区扩展到函数的结束
>
> 注意：go中没有可重入锁，没办法再次获取已经被当前goroutine上锁的锁，这将导致死锁

## 9.3 sync.RWMutex读写锁

```go
var mu sync.RWMutex

mu.RLock()//加读锁
mu.RUnlock()//解读锁
mu.WLock()//加写锁
mu.WUnlock()//解写锁
```

## 9.4 内存同步

## 9.5 sync.Once初始化

如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。果在程序启动的时候就去做这类的初始化的话会增加程序的启动时间并且因为执行的 时候可能也并不需要这些变量所以实际上有一些浪费。

## 9.6 竞争条件检测

在`go build`、`go run`、`go test`命令后加上`-race`的flag

## 9.8 Goroutines和线程

一个goroutine会以一个很小的栈开始其生命周期，一般只需要`2KB`。根据具体需要动态伸缩。

Go的调度器使用了一个叫做`GOMAXPROCS`的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数。